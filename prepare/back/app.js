const http = require('http'); // node 에서 기본적으로 http 모듈 제공

// node 런타임이 코드를 실행해서 http가 서버 역할을 하는거지 node 자체가 서버는 아니다.

const server = http.createServer((req, res) => {
  // 백엔드 서버와 프론트 서버 나누는 이유
  // 대규모 app 대비
  // 프론트는 SSR 백엔드는 API 한 컴퓨터에 두 개를 띄어도 되지만
  // 만약에 프론트 서버에 요청이 1초에 1000개 가 오고 백엔드는 10개로 비대칭적으로 올 때가 있다.
  // 그러면 서버가 메모리나 CPU가 부족해서 터진다.
  // 대비해서 스케일링을 해준다. (컴퓨터를 복사한다 기존거를 통째로)
  // 그러면 프론트 1000 만큼을 나눠 받도록 하지만 여기서 백엔드는 불필요한 낭비가 된다.
  // 이러한 문제로 대규모 프로젝트 같은 경우 각 기능별로 서버로 나누어주는 경우가 많다.
  // 그래야지 그 특정 기능에 데이터 요청이 많이 왔을 때 그 기능만 서버 여러대로 늘려주면 되기 떄문에
  // 한 컴퓨터에다가 모든 기능을 다 넣어두면 그 서버를 스케일링할 때 모든 기능이 복사되는데 그럼 나머지 것들은 쓸모없게 되버리기 때문이다.

  console.log(req.url, req.method);

  if (req.method === 'GET') {
    if (req.url === '/api/posts') {
    }
  } else if (req.method === 'POST') {
  } else if (req.method === 'DELETE') {
  }

  res.write('<h1>Hollo node1</h1>');
  res.write('Hollo node2');
  res.write('Hollo node3');
  res.write('Hollo node4');
  res.end('Hello node8');

  // favicon.ico 는 브라우저 자체가 요청한다. (탭 아이콘)
  // res.end는 마지막에만 쓴다.

  // param req = 브라우저나 프론트서버에서 온 요청에 대한 정보
  // param res = 응답에 대한 정보

  // res.write, res.end 등 red를 사용 = 응답을 보내고 싶을 때
  // req.url, req.method = 요청이 뭔지에 대한 정보를 얻고싶을 때
});

server.listen(3065, () => {
  console.log('서버 실행 중');
});

// res.write로 HTML로 보낼 수 있다. 하지만 이런식으로 줄 구분하면 비효율적이다.
// 서버쪽에 라우터들도 다 쪼갤 필요가 있다.
// 기본 node 제공하는 http로는 코드를 깔끔하게 쪼개기 힘들어서 express 프레임 워크를 사용한다.

// 기본적인 원리는 createServer 곳에서 요청 method나 url에 따라서 응답을 해준다.

// 프론트서버나 브라우저가 요청을 보내면 응답을 해준다. (서버의 기본)
// 요청을 받고 응답을 보낸다.
// 요청 한 번당 응답 한 번
// 아예 안보내도 안된다. 무조건 보내야되고 한 번 요청받고 한 번 응답 보내고 ( 응답을 안 보내면 특정 시간(30초 정도) 후에 브라우저가 자동으로 응답 실패로 처리한다. )

// 만약 여러개의 데이터가 필요하면
// 방법은 다양하지만
// 한 번 요청을 보내서 여러개의 데이터를 동시에 다 묶어서 한 번에 응답을 한다거나
// 요청을 여러번 보내서 거기에 각각 조금씩 응답을 여러번 하거나
// 왜냐하면 요청과 응답은 1 : 1 비율 되야하기 때문에

// node하면서 실수하는 것이 응답을 두 번 보내는 것이다.
// ex) if으로 응답 두번 보내는 것 (res.end를 두 번 사용 X )
